\documentclass{article}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{geometry}
\usepackage{array}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
%\usepackage{algorithm2e}
%\usepackage[noend]{algpseudocode}
\usepackage{algorithm}% http://ctan.org/pkg/algorithm
\usepackage{algpseudocode}% http://ctan.org/pkg/algorithmicx
%https://shantoroy.com/latex/how-to-write-algorithm-in-latex/
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\date{\today}
\author{Tarik Atlaoui}
\lstset{frame=tb,
  language=C,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}
\begin{document}

\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother

\begin{titlepage}
	\enlargethispage{2cm}
	\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
	\center
	\textsc{\LARGE
	SORBONNE UNIVERSITÉ 
	} \\[1cm]
	\HRule \\[0.4cm]
	{ \huge \bfseries Réponse au question du projet Moteur d’exécution de workflows \\[0.15cm] }
	\HRule \\[4cm]
	\large{Tarik Atlaoui} \\[3cm]
	05 Mai 2020 \\[3cm]

\end{titlepage}
                                                                                                                         
\textbf{1. Pourquoi ne peut-on pas utiliser le nom de la méthode en tant qu’identifiant de tâche ?}
\newline
\newline
   Si on utiliser le nom d'une méthode en tant qu'identifiant de tâche l'utilisateur ne pourrais pas surcharger les méthodes.
   Car deux méthode avec le meme nom mais des parametre différent représenterais que un seul noeud
\newline
\newline
\textbf{Exercice 3}
\newline
\textbf{2. Donner les grandes lignes de votre algorithme de la méthode execute. Il est attendu un
algorithme décrit de manière synthétique et non un copier/coller de votre code.}

\begin{algorithm}
  \caption{Algorithm Exercice 3}\label{euclid}
  \begin{algorithmic}[1]
    \Procedure{Execute}{$a,b$}
      \State $G\gets Graph<String>$
      \State $C\gets Context<String , Object>$
      \State $Mtab\gets Method[]$
      \State $result\gets Map<String , Object>$
      \For{\texttt{<node in Graph>}}\Comment{ont execute les method racine et stock}
        \State \texttt{<Chercher la méthode qui correspond au node>}      
        \If{$nodeParam$ is in $C$ or $nodeNbParam$ == 0}
          \State $result\gets resultat$
          \ElsIf{si il y au moins une dépendance qui n'est pas dans C}
          \State $Mtab\gets methode$\Comment{la méthode de node}
        \State Do that as well
        \Else
        \EndIf
        \State \texttt{<invoke methode de node en recupérant les parametre dans C>}
        \EndFor
      \For{\texttt{<m in Mtab>}}
        \State \texttt{<invoke m en recupérant les parametre dans G et C>}
      \EndFor
      \State \textbf{return} $result$
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

Pour résumer l'algorithme utiliser , au debut en recuper touts les resultat des tache racine tout en gardant les méthode 
des autre tache qui peuve pas encore etre executer ,puis ont parcour les méthode réstante et en les execute.
\newline
\newline
\textbf{Exercice 4}
\newline
\textbf{1. Décrire comment vous avez assuré le parallélisme des tâches indépendantes.}
\newline
\newline
    Nous avons considére chaque noeud du graphe et lui avons dédier un thread , il commence par chercher la 
    méthode qu'il doit appeler, puis pour chaqu'un de c'est argument essaye de le recupérer , si ce dernier n'existe pas encore 
    il attend une fois que il a fini de recupérer la valeur de c'est arrgument il invoke la fonction et mets le resultat dans la map
\newline
\newline
\textbf{Exercice 5}
\newline
\textbf{1. Décrire votre protocole de communication}
\newline
Le JobExecutorRemote demande demande le calcule d'un job a une jvm distante puis il peux choisir
celle ci lui renvois un tuple contenant le nombre de tache executer ainsi que la Map String , Object  calculer
\newline
\textbf{2. Justifier votre choix de l’API de communication que vous avez utilisée.}
\newline
Nous avons choisie Rmi , car elle paraissait etre la plus adapter au problem pas besoin de gérez une base de donner 
juste l'execution de tache sur une ou plusieur Jvm, aussi elle incluse avec java donc pas besoin d'installation préalable ce qui est un plus.
\newline
\newline
\textbf{3. Quelle hypothèse doit-on faire sur le type des objets du contexte ? Justifiez.}
\newline
Ont doit fair l'hypothése que les type utiliser dans "Object" sont  sérializable car sinon en peux pas les 
transmetre d'une machine a une autre.
\newline
\newline
\textbf{4. Quel mécanisme avez-vous utilisé pour la notification d’avancement au client ?}
\newline
\newline
Dans le host qui fait le calcule il met une variable a false avants le calcule et a vrai apres des que la tache est fini
il la place a true (l'idéal c'est de gardez une trace car si deux jobe son demander la notification peux etre pertuber)
\newline
\newline
\textbf{Exercice 6}
\newline
\textbf{1. Quel est le protocole de communications entre maître-esclaves et éventuellement entre
esclave-esclave ?}
\newline
\newline
\textbf{2. Comment le maître affecte ses tâches équitablement sur les esclaves ?}
\newline
\newline
\textbf{3. Comment les esclaves sont assurés de respecter leur borne de tâche courante ?}
\newline
\newline
\textbf{4. Comment gérez-vous la communication d’un résultat entre deux tâches dépendantes ? Don-
ner les avantages et les inconvénients de votre solution.}
\newline
\newline
\textbf{5. (niveau 2) Comment gérez-vous le fait d’avoir plusieurs jobs en cours d’exécution sur le
cluster ?}
\newline
\newline
\textbf{6. (niveau 3) Décrire le mécanisme qui permet de détecter la panne d’un esclave. Comment
gérez-vous la réaffectation des tâches perdues ?}

\end{document}
%\begin{algorithm}
%  \caption{Algorithm Exercice 3}\label{euclid}
%  \begin{algorithmic}[1]
%    \Procedure{Execute}{$a,b$}\Comment{The g.c.d. of a and b}
%      \State $r\gets a\bmod b$
%      \While{$r\not=0$}\Comment{We have the answer if r is 0}
%        \State $a\gets b$
%        \State $b\gets r$
%        \State $r\gets a\bmod b$
%      \EndWhile\label{euclidendwhile}
%      \For{\texttt{<some condition>}}
%        \State \texttt{<do stuff>}
%      \EndFor
%      \State \textbf{return} $b$\Comment{The gcd is b}
%    \EndProcedure
%  \end{algorithmic}
%\end{algorithm}